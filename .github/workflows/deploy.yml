name: CI/CD Pipeline for Azure VM

on:
  push:
    branches:
      - main

jobs:
  deploy-to-azure-vm:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Deploy to Azure VM
      uses: appleboy/ssh-action@v0.1.6
      with:
        host: ${{ secrets.AZURE_VM_IP }}
        username: ${{ secrets.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSH_KEY }}
        script: |
          # 1. git 저장소 확인 및 설정
          if [ ! -d "/home/azureuser/webserver" ]; then
            echo "디렉토리가 없습니다. 새로 생성합니다..."
            mkdir -p /home/azureuser/webserver
          fi
          
          cd /home/azureuser/webserver
          
          if [ ! -d ".git" ]; then
            echo "Git 저장소가 아닙니다. 저장소를 초기화합니다..."
            # 기존 내용 백업 (혹시 모를 경우)
            if [ "$(ls -A)" ]; then
              echo "기존 파일이 있습니다. 백업 후 진행합니다..."
              mkdir -p /home/azureuser/webserver_backup
              cp -r * /home/azureuser/webserver_backup/ 2>/dev/null || true
              rm -rf * 2>/dev/null || true
              rm -rf .* 2>/dev/null || true
            fi
            
            git clone https://github.com/NamidaEro/webserver.git /tmp/webserver_temp
            cp -r /tmp/webserver_temp/. /home/azureuser/webserver/
            rm -rf /tmp/webserver_temp
          else
            echo "Git 저장소가 존재합니다. pull 명령을 실행합니다..."
            git reset --hard HEAD
            git clean -fd
            git pull origin main
          fi
          
          # 2. docker-compose 설치 확인 및 설치
          if ! command -v docker-compose &> /dev/null && ! command -v docker compose &> /dev/null; then
            echo "docker-compose가 설치되어 있지 않습니다. 설치를 진행합니다..."
            sudo apt-get update
            sudo apt-get install -y docker-compose-plugin
            
            # 구 버전 docker-compose가 필요한 경우 추가 설치
            if ! command -v docker-compose &> /dev/null; then
              echo "docker compose plugin 대신 독립 실행형 docker-compose를 설치합니다..."
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
          else
            echo "docker-compose가 이미 설치되어 있습니다."
          fi
          
          # 3. .env 파일 확인 및 생성
          if [ ! -f "/home/azureuser/webserver/data-collector/.env" ]; then
            echo "데이터 수집기 .env 파일이 없습니다. 기본 템플릿을 생성합니다..."
            mkdir -p /home/azureuser/webserver/data-collector
            
            # 개별 echo 명령어로 환경 변수 파일 생성
            echo "BLIZZARD_CLIENT_ID=${BLIZZARD_CLIENT_ID}" > /home/azureuser/webserver/data-collector/.env
            echo "BLIZZARD_CLIENT_SECRET=${BLIZZARD_CLIENT_SECRET}" >> /home/azureuser/webserver/data-collector/.env
            echo "BLIZZARD_REGION=kr" >> /home/azureuser/webserver/data-collector/.env
            echo "BLIZZARD_NAMESPACE=dynamic-kr" >> /home/azureuser/webserver/data-collector/.env
            echo "BLIZZARD_LOCALE=ko_KR" >> /home/azureuser/webserver/data-collector/.env
            echo "MONGODB_URI=${MONGODB_URI}" >> /home/azureuser/webserver/data-collector/.env
          fi
          
          # Next.js 환경 변수 설정
          if [ ! -f "/home/azureuser/webserver/nextjs-app/.env" ]; then
            echo "Next.js 앱 .env 파일이 없습니다. 기본 템플릿을 생성합니다..."
            mkdir -p /home/azureuser/webserver/nextjs-app
            
            # MongoDB 관련 환경 변수 설정을 추가합니다
            echo "MONGODB_URI=${MONGODB_URI}" > /home/azureuser/webserver/nextjs-app/.env
          fi
          
          # 4. 서비스 빌드 및 실행
          cd /home/azureuser/webserver
          
          # 로그 디렉토리 생성 및 권한 설정 (이미 존재하면 무시됨)
          mkdir -p /home/azureuser/webserver/logs
          # 다음 chown/chmod는 deploy.yml을 실행하는 사용자가 sudo 권한이 있어야 하며, azureuser의 실제 UID/GID를 알아야 더 정확합니다.
          # 일반적으로 azureuser는 1000:1000 이지만, 환경에 따라 다를 수 있습니다.
          # sudo chown -R 1000:1000 /home/azureuser/webserver/logs # data-collector의 user 설정과 맞춤
          # sudo chmod -R u+rwX,g+rX,o+rX /home/azureuser/webserver/logs # 보다 제한적인 권한 예시
          sudo chown -R azureuser:azureuser /home/azureuser/webserver/logs # 기존 방식 유지 (azureuser가 1000:1000이라고 가정)
          sudo chmod -R 777 /home/azureuser/webserver/logs # 기존 방식 유지 (최소 권한 원칙에는 어긋남)

          # Docker Compose 명령어 실행 함수 정의
          run_docker_compose() {
            if command -v docker-compose &> /dev/null; then
              echo "기존 Docker Compose 명령 사용: docker-compose $@ ($(pwd))"
              sudo docker-compose "$@"
            else
              echo "새 Docker Compose 명령 사용: docker compose $@ ($(pwd))"
              sudo docker compose "$@"
            fi
          }

          echo "===== Docker 환경 정리 시작 ====="
          
          # 단계 1: 모든 Docker Compose 서비스 중지 (현재 프로젝트)
          echo "현재 프로젝트의 모든 Docker Compose 서비스 중지 시도..."
          run_docker_compose down || true 

          # 단계 2: 모든 중지된 컨테이너 삭제
          echo "모든 중지된 컨테이너 삭제 시도..."
          sudo docker container prune -f || true

          # 단계 3: 특정 이미지 (data-collector) 명시적 삭제
          echo "기존 data-collector 이미지 삭제 시도..."
          # docker-compose.yml이 있는 디렉토리 이름(basename)을 프로젝트 이름으로 사용
          PROJECT_NAME=$(basename "$(pwd)")
          # 가능한 이미지 이름 패턴들 (예: webserver_data-collector, webserver-data-collector)
          # GitHub Actions의 checkout 경로에 따라 프로젝트 이름이 webserver가 아닐 수 있으므로, 서비스 이름 자체도 패턴에 추가
          IMAGE_PATTERNS=("${PROJECT_NAME}_data-collector" "${PROJECT_NAME}-data-collector" "data-collector")
          IMAGE_ID_FOUND=""
          for pattern in "${IMAGE_PATTERNS[@]}"; do
            # docker images 결과에서 REPOSITORY가 정확히 일치하는 경우만 찾도록 수정 (예: ubuntu는 되지만 my-ubuntu는 안됨)
            # 또한, 이미지 이름에 latest 외 다른 태그가 붙는 경우도 고려하여 REPOSITORY만 필터링
            IMAGE_IDS=$(sudo docker images --filter=reference="$pattern" -q)
            if [ -n "$IMAGE_IDS" ]; then
              for IMAGE_ID in $IMAGE_IDS; do # 여러 ID가 반환될 수 있음 (다른 태그 등)
                echo "패턴 '$pattern'으로 이미지 ID ($IMAGE_ID) 찾음. 삭제 시도..."
                sudo docker rmi -f $IMAGE_ID || true
                IMAGE_ID_FOUND="true"
              done
            fi
          done
          if [ -z "$IMAGE_ID_FOUND" ]; then
             echo "data-collector 관련 이미지를 찾지 못했습니다."
          fi
          
          # 단계 4: 댕글링 이미지(태그 없는 이미지) 삭제
          echo "댕글링 이미지 삭제 시도..."
          sudo docker image prune -f || true

          # (선택 사항) 단계 5: 사용하지 않는 모든 이미지, 네트워크, 빌드 캐시 정리 - 주의!
          # echo "사용하지 않는 모든 이미지, 네트워크, 빌드 캐시 정리 시도 (볼륨 제외)..."
          # sudo docker system prune -a -f || true 

          echo "===== Docker 환경 정리 완료 ====="

          # 단계 6: 모든 서비스 새로 빌드 및 시작
          echo "모든 서비스 새로 빌드 (--no-cache) 및 시작..."
          run_docker_compose build --no-cache
          run_docker_compose up -d
          
          echo "배포가 완료되었습니다!"
