name: CI/CD Pipeline for Azure VM

on:
  push:
    branches:
      - main

jobs:
  deploy-to-azure-vm:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Deploy to Azure VM
      id: deploy # step에 id를 부여하여 결과 접근 가능
      uses: appleboy/ssh-action@v0.1.6
      env:
        BLIZZARD_CLIENT_ID: ${{ secrets.BLIZZARD_CLIENT_ID }}
        BLIZZARD_CLIENT_SECRET: ${{ secrets.BLIZZARD_CLIENT_SECRET }}
        MONGODB_URI: ${{ secrets.MONGODB_URI }}
      with:
        host: ${{ secrets.AZURE_VM_IP }}
        username: ${{ secrets.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSH_KEY }}
        script: |
          # 1. git 저장소 확인 및 설정
          if [ ! -d "/home/azureuser/webserver" ]; then
            echo "디렉토리가 없습니다. 새로 생성합니다..."
            mkdir -p /home/azureuser/webserver
          fi
          
          cd /home/azureuser/webserver
          
          if [ ! -d ".git" ]; then
            echo "Git 저장소가 아닙니다. 저장소를 초기화합니다..."
            # 기존 내용 백업 (혹시 모를 경우)
            if [ "$(ls -A)" ]; then
              echo "기존 파일이 있습니다. 백업 후 진행합니다..."
              mkdir -p /home/azureuser/webserver_backup
              cp -r * /home/azureuser/webserver_backup/ 2>/dev/null || true
              rm -rf * 2>/dev/null || true
              rm -rf .* 2>/dev/null || true
            fi
            
            git clone https://github.com/NamidaEro/webserver.git /tmp/webserver_temp
            cp -r /tmp/webserver_temp/. /home/azureuser/webserver/
            rm -rf /tmp/webserver_temp
          else
            echo "Git 저장소가 존재합니다. pull 명령을 실행합니다..."
            git reset --hard HEAD
            git clean -fd
            git pull origin main
          fi
          
          # 2. docker-compose 설치 확인 및 설치
          if ! command -v docker-compose &> /dev/null && ! command -v docker compose &> /dev/null; then
            echo "docker-compose가 설치되어 있지 않습니다. 설치를 진행합니다..."
            sudo apt-get update
            sudo apt-get install -y docker-compose-plugin
            
            # 구 버전 docker-compose가 필요한 경우 추가 설치
            if ! command -v docker-compose &> /dev/null; then
              echo "docker compose plugin 대신 독립 실행형 docker-compose를 설치합니다..."
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
          else
            echo "docker-compose가 이미 설치되어 있습니다."
          fi
          
          # 3. .env 파일 확인 및 생성 (data-collector)
          DATA_COLLECTOR_ENV_FILE="/home/azureuser/webserver/data-collector/.env"
          mkdir -p "$(dirname "$DATA_COLLECTOR_ENV_FILE")"
          touch "$DATA_COLLECTOR_ENV_FILE" # 파일이 없으면 생성

          # BLIZZARD 관련 환경 변수 설정 (data-collector) - 파일이 없거나 해당 변수가 없을 때만 추가
          if ! grep -q "^BLIZZARD_CLIENT_ID=" "$DATA_COLLECTOR_ENV_FILE"; then
            echo "BLIZZARD_CLIENT_ID=${BLIZZARD_CLIENT_ID}" >> "$DATA_COLLECTOR_ENV_FILE"
          fi
          if ! grep -q "^BLIZZARD_CLIENT_SECRET=" "$DATA_COLLECTOR_ENV_FILE"; then
            echo "BLIZZARD_CLIENT_SECRET=${BLIZZARD_CLIENT_SECRET}" >> "$DATA_COLLECTOR_ENV_FILE"
          fi
          if ! grep -q "^BLIZZARD_REGION=" "$DATA_COLLECTOR_ENV_FILE"; then
            echo "BLIZZARD_REGION=kr" >> "$DATA_COLLECTOR_ENV_FILE"
          fi
          if ! grep -q "^BLIZZARD_NAMESPACE=" "$DATA_COLLECTOR_ENV_FILE"; then
            echo "BLIZZARD_NAMESPACE=dynamic-kr" >> "$DATA_COLLECTOR_ENV_FILE"
          fi
          if ! grep -q "^BLIZZARD_STATIC_NAMESPACE=" "$DATA_COLLECTOR_ENV_FILE"; then
            echo "BLIZZARD_STATIC_NAMESPACE=static-kr" >> "$DATA_COLLECTOR_ENV_FILE"
          fi
          if ! grep -q "^BLIZZARD_LOCALE=" "$DATA_COLLECTOR_ENV_FILE"; then
            echo "BLIZZARD_LOCALE=ko_KR" >> "$DATA_COLLECTOR_ENV_FILE"
          fi
          
          # MONGODB_URI 설정 (data-collector) - 없으면 추가, 있으면 값 변경
          if grep -q "^MONGODB_URI=" "$DATA_COLLECTOR_ENV_FILE"; then
            # 기존 라인 변경 (macOS 호환성을 위해 sed -i '' 사용)
            sed -i'' -e "s|^MONGODB_URI=.*|MONGODB_URI=${{ env.MONGODB_URI }}|" "$DATA_COLLECTOR_ENV_FILE"
          else
            echo "MONGODB_URI=${{ env.MONGODB_URI }}" >> "$DATA_COLLECTOR_ENV_FILE"
          fi

          # Next.js 환경 변수 설정
          NEXTJS_ENV_FILE="/home/azureuser/webserver/nextjs-app/.env"
          mkdir -p "$(dirname "$NEXTJS_ENV_FILE")"
          touch "$NEXTJS_ENV_FILE" # 파일이 없으면 생성

          # MONGODB_URI 설정 (nextjs-app) - 없으면 추가, 있으면 값 변경
          if grep -q "^MONGODB_URI=" "$NEXTJS_ENV_FILE"; then
            # 기존 라인 변경 (macOS 호환성을 위해 sed -i '' 사용)
            sed -i'' -e "s|^MONGODB_URI=.*|MONGODB_URI=${{ env.MONGODB_URI }}|" "$NEXTJS_ENV_FILE"
          else
            echo "MONGODB_URI=${{ env.MONGODB_URI }}" >> "$NEXTJS_ENV_FILE"
          fi
          
          # 4. 서비스 빌드 및 실행
          cd /home/azureuser/webserver
          
          # 로그 디렉토리 생성 및 권한 설정 (이미 존재하면 무시됨)
          mkdir -p /home/azureuser/webserver/logs
          sudo chown -R azureuser:azureuser /home/azureuser/webserver/logs
          sudo chmod -R 777 /home/azureuser/webserver/logs

          # Docker Compose 명령어 실행 함수 정의
          run_docker_compose() {
            if command -v docker-compose &> /dev/null; then
              echo "기존 Docker Compose 명령 사용: docker-compose $@ ($(pwd))"
              sudo docker-compose "$@"
            else
              echo "새 Docker Compose 명령 사용: docker compose $@ ($(pwd))"
              sudo docker compose "$@"
            fi
          }

          echo "===== Docker 환경 정리 시작 (배포 스크립트 내) ====="
          
          echo "현재 프로젝트의 모든 Docker Compose 서비스 중지 시도..."
          run_docker_compose down || true 

          echo "모든 중지된 컨테이너 삭제 시도..."
          sudo docker container prune -f || true

          echo "기존 data-collector 이미지 삭제 시도..."
          PROJECT_NAME=$(basename "$(pwd)")
          IMAGE_PATTERNS=("${PROJECT_NAME}_data-collector" "${PROJECT_NAME}-data-collector" "data-collector")
          IMAGE_ID_FOUND=""
          for pattern in "${IMAGE_PATTERNS[@]}"; do
            IMAGE_IDS=$(sudo docker images --filter=reference="$pattern" -q)
            if [ -n "$IMAGE_IDS" ]; then
              for IMAGE_ID in $IMAGE_IDS; do
                echo "패턴 '$pattern'으로 이미지 ID ($IMAGE_ID) 찾음. 삭제 시도..."
                sudo docker rmi -f $IMAGE_ID || true
                IMAGE_ID_FOUND="true"
              done
            fi
          done
          if [ -z "$IMAGE_ID_FOUND" ]; then
             echo "data-collector 관련 이미지를 찾지 못했습니다."
          fi
          
          echo "기존 nextjs-app 이미지 삭제 시도..."
          # nextjs-app 이미지 패턴 (docker-compose.yml 설정에 따라 다를 수 있음)
          # 일반적으로 프로젝트명_서비스명 또는 프로젝트명-서비스명 형태
          NEXTJS_IMAGE_PATTERNS=("${PROJECT_NAME}_nextjs-app" "${PROJECT_NAME}-nextjs-app" "nextjs-app")
          NEXTJS_IMAGE_ID_FOUND=""
          for pattern in "${NEXTJS_IMAGE_PATTERNS[@]}"; do
            IMAGE_IDS=$(sudo docker images --filter=reference="$pattern" -q)
            if [ -n "$IMAGE_IDS" ]; then
              for IMAGE_ID in $IMAGE_IDS; do
                echo "패턴 '$pattern'으로 nextjs-app 이미지 ID ($IMAGE_ID) 찾음. 삭제 시도..."
                sudo docker rmi -f $IMAGE_ID || true
                NEXTJS_IMAGE_ID_FOUND="true"
              done
            fi
          done
          if [ -z "$NEXTJS_IMAGE_ID_FOUND" ]; then
             echo "nextjs-app 관련 이미지를 찾지 못했습니다. (이는 정상일 수 있습니다. docker-compose가 기본 이름으로 빌드합니다)"
          fi
          
          # === 추가된 부분 시작: server-admin 이미지 삭제 로직 ===
          echo "기존 server-admin 이미지 삭제 시도..."
          # server-admin 이미지 패턴
          SERVER_ADMIN_IMAGE_PATTERNS=("${PROJECT_NAME}_server-admin" "${PROJECT_NAME}-server-admin" "server-admin")
          SERVER_ADMIN_IMAGE_ID_FOUND=""
          for pattern in "${SERVER_ADMIN_IMAGE_PATTERNS[@]}"; do
            IMAGE_IDS=$(sudo docker images --filter=reference="$pattern" -q)
            if [ -n "$IMAGE_IDS" ]; then
              for IMAGE_ID in $IMAGE_IDS; do
                echo "패턴 '$pattern'으로 server-admin 이미지 ID ($IMAGE_ID) 찾음. 삭제 시도..."
                sudo docker rmi -f $IMAGE_ID || true
                SERVER_ADMIN_IMAGE_ID_FOUND="true"
              done
            fi
          done
          if [ -z "$SERVER_ADMIN_IMAGE_ID_FOUND" ]; then
             echo "server-admin 관련 이미지를 찾지 못했습니다. (이는 정상일 수 있습니다. docker-compose가 기본 이름으로 빌드합니다)"
          fi
          # === 추가된 부분 끝 ===
          
          echo "댕글링 이미지 삭제 시도 (배포 스크립트 내)..."
          sudo docker image prune -f || true

          echo "===== Docker 환경 정리 완료 (배포 스크립트 내) ====="

          echo "모든 서비스 새로 빌드 (--no-cache) 및 시작..."
          # MONGODB_URI 값 디버그 출력 추가
          echo "Debug: MONGODB_URI in script is '${{ env.MONGODB_URI }}'"
          # nextjs-app 빌드 시 --build-arg를 사용하여 MONGODB_URI 명시적 전달
          run_docker_compose build --no-cache --build-arg MONGODB_URI="${{ env.MONGODB_URI }}" nextjs-app
          run_docker_compose build --no-cache data-collector 
          run_docker_compose build --no-cache server-admin
          
          run_docker_compose up -d
          
          echo "배포가 완료되었습니다!"

    - name: Cleanup Docker resources on Azure VM
      if: always() # 이전 단계의 성공/실패 여부와 관계없이 항상 실행
      uses: appleboy/ssh-action@v0.1.6
      with:
        host: ${{ secrets.AZURE_VM_IP }}
        username: ${{ secrets.AZURE_VM_USERNAME }}
        key: ${{ secrets.AZURE_VM_SSH_KEY }}
        script: |
          echo "===== Docker 리소스 정리 시작 (항상 실행) ====="
          echo "댕글링 이미지 삭제 시도 (항상 실행)..."
          sudo docker image prune -f || true
          echo "중지된 컨테이너 삭제 시도 (항상 실행)..."
          sudo docker container prune -f || true
          echo "===== Docker 리소스 정리 완료 (항상 실행) ====="
